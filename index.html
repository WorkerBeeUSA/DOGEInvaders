<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOGE Invaders | Political Satire Arcade Game</title>
    <meta name="description" content="Play DOGE Invaders, a politically satirical Space Invaders clone where you battle government waste or defend federal jobs.">
    <meta name="keywords" content="space invaders, political game, satire game, DOGE, government, browser game, HTML5 game, javascript game">
    
    <!-- Favicon -->
    <!-- <link rel="icon" type="image/png" href="favicon.png"> -->
    
    <!-- Open Graph tags for social media sharing -->
    <meta property="og:title" content="DOGE Invaders | Political Satire Game">
    <meta property="og:description" content="A politically satirical Space Invaders clone where bureaucracy meets budget cuts in an epic battle.">
    <meta property="og:url" content="https://DOGEInvaders.com/">
    <meta property="og:type" content="website">
    
    <!-- Twitter Card tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="DOGE Invaders | Political Satire Game">
    <meta name="twitter:description" content="A politically satirical Space Invaders clone where bureaucracy meets budget cuts in an epic battle.">
    <!-- meta name="twitter:image" content="https://dogeinvaders.com/doge-invaders-preview.jpg">
    
    <!-- Canonical URL to prevent duplicate content issues -->
    <!-- link rel="canonical" href="https://dogeinvaders.com/">
    
    <!-- Structured data for rich results -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "DOGE Invaders",
      "description": "A politically satirical Space Invaders clone where bureaucracy meets budget cuts.",
      "genre": ["Arcade", "Political Satire"],
      "gamePlatform": "Web Browser",
      "applicationCategory": "Game",
      "operatingSystem": "Any",
    }
    </script>
	
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
			-webkit-user-select: none;
        	-moz-user-select: none;
        	-ms-user-select: none;
        	user-select: none;
        }

		html, body {
	        overscroll-behavior: none;
	        overflow: hidden;
	        position: fixed;
	        width: 100%;
	        height: 100%;
	    }

        body {
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        #outer-container {
            position: relative;
            width: 100%;
            max-width: 550px;
            height: 100%;
            max-height: 900px;
            border: 4px solid #ffcc00;
            background-color: #111;
            padding: 10px;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: calc(100% - 80px); /* Leave room for HUD */
            margin: 0 auto;
            border: 2px solid #333;
            overflow: hidden;
        }

        #hud-container {
            position: relative;
            width: 100%;
            height: 70px;
            padding: 5px 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid #333;
            background-color: #222;
        }

        .hud-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .hud-section.right {
            align-items: flex-end;
        }

        .hud-section.center {
            align-items: center;
        }

        canvas {
            display: block;
            background-color: #000;
            width: 100%;
            height: 100%;
			touch-action: none;
        }

        .game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 20px;
            text-align: center;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            background-color: #ff0000;
            color: #fff;
            border: 4px solid #fff;
            padding: 15px 25px;
            margin: 15px;
            cursor: pointer;
            font-size: 18px;
            text-shadow: 2px 2px 0 #000;
        }

        button:hover {
            background-color: #ff4400;
            transform: scale(1.05);
        }

        .character-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-top: 20px;
        }

        .character-option {
            text-align: center;
            cursor: pointer;
            padding: 15px;
            border: 4px solid #444;
            transition: all 0.3s;
            border-radius: 5px;
            background-color: rgba(50, 50, 50, 0.7);
            margin-bottom: 15px;
            width: 80%;
        }

        .character-option:hover {
            transform: scale(1.05);
            border-color: #fff;
            background-color: rgba(100, 100, 100, 0.7);
        }

        .character-svg {
            width: 100px;
            height: 120px;
            margin: 0 auto 15px auto;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .character-option p {
            margin-bottom: 10px;
            font-size: 14px;
            color: #ffcc00;
            text-shadow: 2px 2px 0 #000;
        }

        h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ffcc00;
            text-shadow: 3px 3px 0 #ff0000;
        }

        #mobile-controls-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 90px; /* Increased height for buttons */
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 50;
        }

        #mobile-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            height: 100%;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            border: 3px solid white;
            user-select: none;
        }

        .fire-btn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 204, 0, 0.5);
        }

        .sound-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 100;
        }

        .donation-panel {
            margin-top: 20px;
            text-align: center;
            font-size: 12px;
            max-width: 320px;
            background-color: rgba(50, 50, 50, 0.7);
            padding: 15px;
            border-radius: 5px;
            border: 2px solid #444;
        }

        .donation-panel p {
            margin-bottom: 10px;
            color: #ffcc00;
        }

        #level-message {
            font-size: 20px;
            color: #ffcc00;
            margin: 20px 0;
            text-shadow: 2px 2px 0 #000;
            max-width: 80%;
            text-align: center;
        }

        #game-title {
            font-size: 32px;
            text-align: center;
            color: #ffcc00;
            text-shadow: 3px 3px #ff0000;
            margin: 10px 0 5px 0;
        }

        #game-subtitle {
            font-size: 12px;
            text-align: center;
            color: #fff;
            margin-bottom: 10px;
        }

        #choose-character {
            font-size: 18px;
            text-align: center;
            color: #ffcc00;
            margin-bottom: 10px;
        }

        #sound-setup-prompt {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }
        
        #sound-setup-prompt p {
            margin-bottom: 20px;
            font-size: 18px;
            color: #fff;
        }
        
        #sound-setup-button {
            padding: 15px 30px;
            font-size: 20px;
            background-color: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        @media (max-width: 800px) {
            #outer-container {
                height: 100vh;
            }
            
            #mobile-controls-container {
                display: block;
            }
            
            #game-container {
                height: calc(100% - 80px - 90px); /* Adjust for HUD and controls */
            }
            
            button {
                padding: 12px 20px;
                font-size: 16px;
            }
            
            h1 {
                font-size: 28px;
            }

            .character-svg {
                width: 80px;
                height: 100px;
            }
            
            .hud-section {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="outer-container">
        <div id="hud-container">
            <div class="hud-section left">
                <div id="score">SCORE: 0</div>
                <div id="high-score">HIGH: 0</div>
            </div>
            <div class="hud-section center">
                <div id="level">LEVEL: 1</div>
                <div id="power-up" style="color: #ffcc00;"></div>
            </div>
            <div class="hud-section right">
                <div id="lives">LIVES: 3</div>
                <div id="sound-status">SOUND: ON</div>
            </div>
        </div>
        
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            
            <div id="start-screen" class="game-screen">
                <div id="game-title">DOGE INVADERS</div>
                <div id="game-subtitle">A politically satirical Space Invaders clone</div>
                <div id="choose-character">Choose your character!</div>
                <div class="character-selection">
                    <div class="character-option" id="fed-employee">
                        <div class="character-svg" id="fed-svg"></div>
                        <p>Fed Employee</p>
                        <p>Defending stable government jobs</p>
                    </div>
                    <div class="character-option" id="doge-employee">
                        <div class="character-svg" id="doge-svg"></div>
                        <p>DOGE Employee</p>
                        <p>Cutting government waste</p>
                    </div>
                </div>
            </div>
            
            <div id="game-over-screen" class="game-screen hidden">
                <h1>GAME OVER</h1>
                <p style="font-size: 20px; color: #ff0000; margin: 15px 0;">Final Score: <span id="final-score">0</span></p>
                <p style="font-size: 18px; color: #ffcc00; margin-bottom: 20px;">High Score: <span id="final-high-score">0</span></p>
                <button id="restart-button">Play Again</button>
                <div class="donation-panel">
                    <p>Support our game:</p>
                    <p>Github <a href="https://github.com/WorkerBeeUSA/DOGEInvaders">repository</a></p>
                </div>
            </div>
            
            <div id="level-complete-screen" class="game-screen hidden">
                <h1>LEVEL COMPLETE!</h1>
                <p id="level-message"></p>
                <button id="next-level-button">Next Level</button>
            </div>
        </div>
        
        <div id="mobile-controls-container">
            <div id="mobile-controls">
                <div class="mobile-btn" id="left-btn">◀</div>
                <div class="mobile-btn fire-btn" id="fire-btn">FIRE</div>
                <div class="mobile-btn" id="right-btn">▶</div>
            </div>
        </div>
    </div>

    <!-- Sound setup prompt for mobile -->
    <div id="sound-setup-prompt" class="hidden">
        <p>Tap the button below to enable game sounds</p>
        <button id="sound-setup-button">ENABLE SOUND</button>
    </div>

    <script>
        (function() {
            // Constants and configuration
            const CANVAS_WIDTH = 500;
            const CANVAS_HEIGHT = 700;
            const PLAYER_WIDTH = 50;
            const PLAYER_HEIGHT = 40;
            const ENEMY_WIDTH = 40;
            const ENEMY_HEIGHT = 35;
            const PROJECTILE_WIDTH = 8;
            const PROJECTILE_HEIGHT = 15;
            const ENEMY_ROWS = 4;
            const ENEMY_COLS = 6;
            const ENEMY_PADDING = 15;
            
            // Game state
            let canvas, ctx;
            let gameState = 'start';
            let lastTime = 0;
            let score = 0;
            let level = 1;
            let lives = 3;
            let characterType = '';
            let isMobile = false;
            let soundEnabled = true;
            let soundInitialized = false;
            
            // Player state
            let player = {
                x: 0,
                y: 0,
                width: PLAYER_WIDTH,
                height: PLAYER_HEIGHT,
                speed: 0.4, // SLOWED DOWN
                projectileSpeed: 1.2,
                lastFired: 0,
                fireDelay: 300, // SLOWED DOWN
                isRapidFire: false,
                rapidFireTime: 0,
                powerUpDuration: 8000
            };
            
            // Enemy formation
            let enemies = [];
            let formationDirection = 1;
            let formationSpeed = 0.1; // SLOWED DOWN
            let formationDropDistance = 20;
            let enemyFireRate = 0.002; // SLOWED DOWN
            
            // Projectiles
            let playerProjectiles = [];
            let enemyProjectiles = [];
            
            // Power-ups
            let powerUps = [];
            let powerUpChance = 0.0003; // SLOWED DOWN
            let lastPowerUpTime = 0;
            
            // Speech bubbles
            let speechBubbles = [];
            
            // Visual effects
            let defeatedEnemies = [];
            let screenShake = {
                intensity: 0,
                duration: 0,
                timeLeft: 0
            };
            
            // Keyboard input tracking
            const keys = {
                left: false,
                right: false,
                fire: false
            };
            
            // Audio context and sounds
            let audioContext;
            let audioInitialized = false;
            
			const fedBossQuotes = [
				"Who will protect endangered species?",
				"National security will be compromised!",
				"Critical infrastructure will fail!",
				"Drug safety testing will stop!",
				"Veterans' benefits will be delayed!",
				"Air traffic control might collapse!",
				"Food safety inspection will end!",
				"Weather forecasting will suffer!",
				"The national archives need preservation!"
			];
			
			const fedEnemyQuotes = [
				"I've never deleted an email!",
				"My form has its own form!",
				"I cc everyone, just in case!",
				"Meetings about meetings!",
				"I've perfected strategic delay!",
				"My inbox has 10,000 unread items!",
				"My process has 17 approval steps!",
				"I schedule meetings in 30-minute blocks!",
				"My desk plant is government property!"
			];
			
			const dogeBossQuotes = [
				"Replace workers with an app!",
				"Disrupt the bureaucratic paradigm!",
				"Government should fail faster!",
				"Your department is redundant!",
				"Efficiency over experience!",
				"Your job can be automated!",
				"Cut first, ask questions later!",
				"Metrics over mission!",
				"Pivot the regulatory framework!"
			];
			
			const dogeEnemyQuotes = [
				"I sleep four hours and call it optimal!",
				"Measure bathroom breaks to the second!",
				"Replaced manuals with QR codes!",
				"Eliminated three departments today!",
				"My KPIs are never low enough!",
				"Meetings should be 15 minutes max!",
				"Who needs institutional memory?",
				"I've optimized paper clip usage!",
				"Turned your job into a flowchart!"
			];

			const dogeLevelMessages = [
			    "Saved $2.3M by replacing the FDA inspection team with a QR code system!",
			    "Saved $8.7M by outsourcing background checks to an overseas contractor!",
			    "Saved $12.4M by replacing the USDA food safety lab with an app!",
			    "Saved $3.1M by converting National Weather Service to a subscription model!",
			    "Saved $5.8M by replacing the EPA water testing protocol with self-reporting!",
			    "Saved $7.2M by converting all national park rangers to part-time contractors!",
			    "Saved $9.5M by reducing embassy security to a smart doorbell system!",
			    "Saved $4.3M by replacing the Census Bureau with social media analytics!",
			    "Saved $6.7M by converting the National Archives to a blockchain solution!",
			    "Saved $11.2M by replacing FEMA disaster response with a peer-to-peer app!",
			    "Saved $15.4M by replacing air traffic control towers with an automated system!"
			];

			const fedLevelMessages = [
			    "My cubicle plant has survived three administrations!",
			    "Only 4,721 days until retirement, but who's counting?",
			    "They named a form after me: Form 27B-6, 'The Johnson Protocol'!",
			    "My inbox has emails from 2008 I still haven't read!",
			    "My ergonomic chair request was finally approved after 6 years!",
			    "I've collected every commemorative government pen since 2001!",
			    "I've survived 12 'government efficiency initiatives' so far!",
			    "My office softball team is undefeated against Treasury!",
			    "I know where all the working vending machines are!",
			    "My security clearance just got upgraded, job security!",
			    "I've attended 437 mandatory training sessions and counting!",
			    "My pension calculation spreadsheet is my team's most popular file!",
			    "The FAR is more than a reference, it's a way of life!",
			    "My email signature is unmatched!"
			];
			
            // SVG definitions with improved pixel art styling
            const svgDefs = {
                fedPlayer: `
                    <svg viewBox="0 0 30 40" xmlns="http://www.w3.org/2000/svg">
                        <rect x="10" y="22" width="10" height="8" fill="#000080" />
                        <rect x="7" y="10" width="16" height="12" fill="#000080" />
                        <rect x="11" y="10" width="8" height="12" fill="#ffffff" />
                        <rect x="14.5" y="10" width="1" height="12" fill="#ff0000" />
                        <circle cx="15" cy="7" r="4" fill="#ffcc99" />
                    </svg>
                `,
                dogePlayer: `
                    <svg viewBox="0 0 30 40" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="15" cy="11" r="4" fill="#ffcc99" />
                        <rect x="10" y="11" width="10" height="13" fill="#444" />
                        <rect x="10" y="24" width="10" height="6" fill="#444" />
                        <rect x="10" y="7" width="10" height="3" fill="#000" />
                        <rect x="11" y="4" width="8" height="3" fill="#000" />
                        <path d="M11 7 L14 9 L17 7" fill="none" stroke="#fff" stroke-width="0.5" />
                    </svg>
                `,
                fedEnemy: `
                    <svg viewBox="0 0 30 40" xmlns="http://www.w3.org/2000/svg">
                        <rect x="5" y="16" width="15" height="10" fill="#000080" />
                        <rect x="2" y="6" width="21" height="10" fill="#000080" />
                        <rect x="7" y="6" width="11" height="10" fill="#ffffff" />
                        <rect x="12" y="6" width="1" height="10" fill="#ff0000" />
                        <circle cx="12.5" cy="3" r="3" fill="#ffcc99" />
                    </svg>
                `,
                dogeEnemy: `
                    <svg viewBox="0 0 30 40" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12.5" cy="7" r="4" fill="#ffcc99" />
                        <rect x="7.5" y="7" width="10" height="13" fill="#444" />
                        <rect x="7.5" y="20" width="10" height="5" fill="#444" />
                        <rect x="7.5" y="3" width="10" height="3" fill="#aa0000" />
                        <rect x="8.5" y="0" width="8" height="3" fill="#aa0000" />
                        <path d="M8.5 3 L11.5 5 L14.5 3" fill="none" stroke="#fff" stroke-width="0.5" />
                    </svg>
                `,
                fedBoss: `
                    <svg viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                        <rect x="10" y="26" width="20" height="16" fill="#000080" />
                        <rect x="4" y="10" width="32" height="16" fill="#000080" />
                        <rect x="12" y="10" width="16" height="16" fill="#ffffff" />
                        <rect x="19.5" y="10" width="1" height="16" fill="#ff0000" />
                        <circle cx="20" cy="6" r="6" fill="#ffcc99" />
                        <path d="M14,2 Q20,-2 26,2 L26,6 L14,6 Z" fill="#8B4513" />
                    </svg>
                `,
                dogeBoss: `
                    <svg viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="20" cy="14" r="8" fill="#ffcc99" />
                        <rect x="10" y="14" width="20" height="26" fill="#444" />
                        <rect x="10" y="40" width="20" height="10" fill="#444" />
                        <rect x="10" y="6" width="20" height="6" fill="#aa0000" />
                        <rect x="12" y="0" width="16" height="6" fill="#aa0000" />
                        <path d="M12 6 L20 10 L28 6" fill="none" stroke="#fff" stroke-width="1" />
                    </svg>
                `,
                projectileGavel: `
                    <svg viewBox="0 0 10 15" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3.5" y="8" width="3" height="7" fill="#8B4513"/> <!-- Handle -->
                        <rect x="2" y="5" width="6" height="3" fill="#8B4513"/> <!-- Head -->
                        <rect x="1" y="3" width="8" height="2" fill="#dda15e"/> <!-- Wood block -->
                    </svg>
                `,
                projectilePaper: `
                    <svg viewBox="0 0 10 15" xmlns="http://www.w3.org/2000/svg">
                        <rect x="1" y="1" width="8" height="12" fill="#ffffff"/> <!-- Paper -->
                        <path d="M1,1 L9,1 L9,13 L1,13 Z" stroke="#000" stroke-width="0.5" fill="none"/> <!-- Border -->
                        <line x1="2" y1="3" x2="8" y2="3" stroke="#000" stroke-width="0.5"/> <!-- Line 1 -->
                        <line x1="2" y1="5" x2="8" y2="5" stroke="#000" stroke-width="0.5"/> <!-- Line 2 -->
                        <line x1="2" y1="7" x2="8" y2="7" stroke="#000" stroke-width="0.5"/> <!-- Line 3 -->
                        <line x1="2" y1="9" x2="8" y2="9" stroke="#000" stroke-width="0.5"/> <!-- Line 4 -->
                        <line x1="2" y1="11" x2="6" y2="11" stroke="#000" stroke-width="0.5"/> <!-- Line 5 -->
                    </svg>
                `,
                projectileDollar: `
                    <svg viewBox="0 0 10 15" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="5" cy="7.5" r="6" fill="#4CAF50"/> <!-- Green background -->
                        <text x="5" y="11" font-family="Arial" font-size="10" font-weight="bold" text-anchor="middle" fill="#fff">$</text>
                    </svg>
                `,
                enemyProjectile: `
                    <svg viewBox="0 0 10 15" xmlns="http://www.w3.org/2000/svg">
                        <rect x="0" y="0" width="10" height="15" fill="#ff0000"/>
                    </svg>
                `,
                powerUp: `
                    <svg viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="15" cy="15" r="15" fill="#00ff00"/>
                        <text x="15" y="20" font-size="16" text-anchor="middle" fill="#000">P</text>
                    </svg>
                `,
                soundOn: `
                    <svg viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg">
                        <path d="M 0,10 L 8,10 L 18,5 L 18,25 L 8,20 L 0,20 Z" fill="#ffffff"/>
                        <path d="M 20,10 Q 25,15 20,20" stroke="#ffffff" stroke-width="2" fill="none"/>
                        <path d="M 22,5 Q 30,15 22,25" stroke="#ffffff" stroke-width="2" fill="none"/>
                    </svg>
                `,
                soundOff: `
                    <svg viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg">
                        <path d="M 0,10 L 8,10 L 18,5 L 18,25 L 8,20 L 0,20 Z" fill="#ffffff"/>
                        <path d="M 20,10 L 30,20" stroke="#ffffff" stroke-width="2"/>
                        <path d="M 20,20 L 30,10" stroke="#ffffff" stroke-width="2"/>
                    </svg>
                `
            };

            // SVG cache for better performance
            const svgCache = {};

			// Prevent pinch-zoom and double-tap zoom gestures
		    document.addEventListener('touchstart', function(event) {
		        if (event.touches.length > 1) {
		            event.preventDefault();
		        }
		    }, { passive: false });
		    
		    let lastTouchEnd = 0;
		    document.addEventListener('touchend', function(event) {
		        const now = Date.now();
		        if (now - lastTouchEnd <= 300) {
		            event.preventDefault();
		        }
		        lastTouchEnd = now;
		    }, { passive: false });
		    
		    // Prevent context menu on long press
		    document.addEventListener('contextmenu', function(event) {
		        event.preventDefault();
		    });
		    
		    // Prevent pull-to-refresh on mobile browsers
		    document.body.addEventListener('touchmove', function(event) {
		        if (event.touches.length > 1 || event.scale !== undefined && event.scale !== 1) {
		            event.preventDefault();
		        }
		    }, { passive: false });
			
            // Initialize the game
            function init() {
                canvas = document.getElementById('game-canvas');
                ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
                
                // Check if on mobile
                checkMobile();
                
                // Set up event listeners
                document.getElementById('fed-employee').addEventListener('click', () => selectCharacter('fed'));
                document.getElementById('doge-employee').addEventListener('click', () => selectCharacter('doge'));
                document.getElementById('restart-button').addEventListener('click', restartGame);
                document.getElementById('next-level-button').addEventListener('click', startNextLevel);
                
                // Set up sound toggle
                document.getElementById('sound-status').addEventListener('click', toggleSound);
                
                // Set up sound setup for mobile
                document.getElementById('sound-setup-button').addEventListener('click', setupSoundForMobile);
                
                // Set up character SVGs
                document.getElementById('fed-svg').innerHTML = svgDefs.fedPlayer;
                document.getElementById('doge-svg').innerHTML = svgDefs.dogePlayer;
                
                // Set up keyboard controls
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                
                // Set up mobile controls
                setupMobileControls();
                
                // Initialize SVG cache for better performance
                initSVGCache();
                
                // Load high score
                loadHighScore();
                
                // Show sound prompt on mobile
                if (isMobile) {
                    document.getElementById('sound-setup-prompt').classList.remove('hidden');
                } else {
                    // Show start screen immediately on desktop
                    setGameState('start');
                }
            }
            
            function checkMobile() {
                isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 800;
            }
            
            function setupMobileControls() {
                if (!isMobile) return;
                
                const leftBtn = document.getElementById('left-btn');
                const rightBtn = document.getElementById('right-btn');
                const fireBtn = document.getElementById('fire-btn');
                
                // Use touch events for mobile controls
                leftBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keys.left = true;
                });
                
                leftBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keys.left = false;
                });
                
                rightBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keys.right = true;
                });
                
                rightBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keys.right = false;
                });
                
                fireBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keys.fire = true;
                });
                
                fireBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keys.fire = false;
                });
            }
            
            function setupSoundForMobile() {
                // Initialize sound on direct user interaction
                initAudio();
                
                // Hide the sound setup prompt
                document.getElementById('sound-setup-prompt').classList.add('hidden');
                
                // Show start screen
                setGameState('start');
            }
            
            // Initialize SVG cache by pre-rendering SVGs
            function initSVGCache() {
                for (const key in svgDefs) {
                    const img = new Image();
                    const svgBlob = new Blob([svgDefs[key]], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(svgBlob);
                    
                    img.onload = function() {
                        svgCache[key] = img;
                        URL.revokeObjectURL(url);
                    };
                    
                    img.src = url;
                }
            }

            // Initialize Audio Context with fallbacks
            function initAudio() {
                if (audioInitialized) return true;
                
                try {
                    // Create audio context based on browser support
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        audioContext = new AudioContext();
                        
                        // Resume audio context (needed for mobile)
                        if (audioContext.state === 'suspended') {
                            audioContext.resume();
                        }
                        
                        // Load sound preferences
                        soundEnabled = localStorage.getItem('soundEnabled') !== 'false';
                        updateSoundToggle();
                        
                        // Test sound to ensure audio is working
                        playTestSound();
                        
                        audioInitialized = true;
                        soundInitialized = true;
                        return true;
                    }
                } catch (e) {
                    console.error("Web Audio API not supported:", e);
                }
                
                return false;
            }
            
            function playTestSound() {
                try {
                    if (!audioContext) return;
                    
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440;
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.error("Error playing test sound:", e);
                }
            }
            
            // Sound functions - SMOOTHED SOUNDS
            function playShoot() {
                if (!soundEnabled || !soundInitialized) {
                    if (!audioContext && soundEnabled) {
                        initAudio();
                    }
                    if (!soundInitialized) return;
                }
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    // Use a smoother waveform
                    oscillator.type = 'triangle';
                    oscillator.frequency.value = 440; // Lower frequency for less sharpness
                    
                    // Gentler attack and release
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                } catch (e) {
                    console.error("Error playing shoot sound:", e);
                }
            }
            
            function playEnemyHit() {
                if (!soundEnabled || !soundInitialized) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    // Use a smoother waveform
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 0.3);
                    
                    // Gentler attack and longer release
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                } catch (e) {
                    console.error("Error playing enemy hit sound:", e);
                }
            }
            
            function playPowerup() {
                if (!soundEnabled || !soundInitialized) return;
                
                try {
                    const notes = [330, 440, 550];
                    const noteDuration = 0.1;
                    
                    for (let i = 0; i < notes.length; i++) {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        // Smoother sine wave
                        oscillator.type = 'sine';
                        oscillator.frequency.value = notes[i];
                        
                        // Gentler attack and release
                        const startTime = audioContext.currentTime + i * noteDuration;
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.15, startTime + 0.03);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + noteDuration);
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.start(startTime);
                        oscillator.stop(startTime + noteDuration);
                    }
                } catch (e) {
                    console.error("Error playing powerup sound:", e);
                }
            }
            
            function playLevelComplete() {
                if (!soundEnabled || !soundInitialized) return;
                
                try {
                    const notes = [330, 392, 440, 523];
                    const noteDuration = 0.25;
                    
                    for (let i = 0; i < notes.length; i++) {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        // Smoother sine wave
                        oscillator.type = 'sine';
                        oscillator.frequency.value = notes[i];
                        
                        // Gentler attack and release
                        const startTime = audioContext.currentTime + i * noteDuration;
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.2, startTime + 0.05);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + noteDuration);
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.start(startTime);
                        oscillator.stop(startTime + noteDuration);
                    }
                } catch (e) {
                    console.error("Error playing level complete sound:", e);
                }
            }
            
            function playGameOver() {
                if (!soundEnabled || !soundInitialized) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    // Smoother sine wave
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(220, audioContext.currentTime + 1.0);
                    
                    // Gentler attack and release
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 1.0);
                } catch (e) {
                    console.error("Error playing game over sound:", e);
                }
            }
            
            function playEnemyProjectile() {
                if (!soundEnabled || !soundInitialized) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    // Smoother sine wave
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 180;
                    
                    // Gentler attack and release
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                } catch (e) {
                    console.error("Error playing enemy projectile sound:", e);
                }
            }
            
            // Toggle sound on/off
            function toggleSound() {
                soundEnabled = !soundEnabled;
                updateSoundToggle();
                
                // Save preference
                localStorage.setItem('soundEnabled', soundEnabled);
                
                // Initialize audio if turning on sound and not already initialized
                if (soundEnabled && !audioInitialized) {
                    initAudio();
                }
            }
            
            // Update sound toggle status
            function updateSoundToggle() {
                document.getElementById('sound-status').textContent = soundEnabled ? "SOUND: ON" : "SOUND: OFF";
            }
            
            // Set game state and show/hide appropriate screens
            function setGameState(state) {
                gameState = state;
                
                // Hide all screens
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('game-over-screen').classList.add('hidden');
                document.getElementById('level-complete-screen').classList.add('hidden');
                
                // Show appropriate screen
                if (state === 'start') {
                    document.getElementById('start-screen').classList.remove('hidden');
                } else if (state === 'gameOver') {
                    document.getElementById('final-score').textContent = score;
                    document.getElementById('final-high-score').textContent = getHighScore();
                    document.getElementById('game-over-screen').classList.remove('hidden');
                    playGameOver();
                } else if (state === 'levelComplete') {
                    const messageArray = characterType === 'fed' ? fedLevelMessages : dogeLevelMessages;
                    const messageIndex = (level - 1) % messageArray.length;
                    document.getElementById('level-message').textContent = messageArray[messageIndex];
                    document.getElementById('level-complete-screen').classList.remove('hidden');
                    playLevelComplete();
                }
            }
            
            // Handle character selection
            function selectCharacter(type) {
                characterType = type;
                resetGame();
                setGameState('playing');
                
                // Start game loop
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
            
            // Reset game state for a new game
            function resetGame() {
                score = 0;
                level = 1;
                lives = 3;
                
                resetLevel();
            }
            
            // Reset level state
            function resetLevel() {
                // Reset player
                player.x = (canvas.width - player.width) / 2;
                player.y = canvas.height - player.height - (isMobile ? 100 : 20); // Higher position for mobile
                player.isRapidFire = false;
                
                // Clear projectiles
                playerProjectiles = [];
                enemyProjectiles = [];
                
                // Clear power-ups
                powerUps = [];
                
                // Clear speech bubbles
                speechBubbles = [];
                
                // Clear visual effects
                defeatedEnemies = [];
                screenShake = { intensity: 0, duration: 0, timeLeft: 0 };
                
                // Reset formation direction
                formationDirection = 1;
                
                // Set formation speed based on level
                formationSpeed = 0.1 + (level - 1) * 0.05;
                
                // Set enemy fire rate based on level
                enemyFireRate = 0.002 + (level - 1) * 0.0005;
                
                // Create enemy formation
                createEnemies();
                
                // Update HUD
                updateHUD();
            }
            
            // Create enemy formation - START LOWER DOWN
            function createEnemies() {
                enemies = [];
                
                const enemyType = characterType === 'fed' ? 'doge' : 'fed';
                const rows = isMobile ? Math.min(3, ENEMY_ROWS) : ENEMY_ROWS;
                const cols = isMobile ? Math.min(5, ENEMY_COLS) : ENEMY_COLS;
                
                // Calculate starting position to center formation
                const formationWidth = cols * (ENEMY_WIDTH + ENEMY_PADDING) - ENEMY_PADDING;
                const startX = (canvas.width - formationWidth) / 2;
                const startY = 120; // INCREASED - now starting lower
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        // Determine if this is a boss (every 3rd level, first row)
                        const isBoss = level % 3 === 0 && row === 0;
                        
                        // Create enemy
                        const enemy = {
                            x: startX + col * (ENEMY_WIDTH + ENEMY_PADDING),
                            y: startY + row * (ENEMY_HEIGHT + ENEMY_PADDING),
                            width: isBoss ? 60 : ENEMY_WIDTH,
                            height: isBoss ? 50 : ENEMY_HEIGHT,
                            health: isBoss ? 5 + Math.floor(level / 3) : 1,
                            type: enemyType,
                            isBoss: isBoss,
                            lastSpeechTime: 0,
                            speechChance: isBoss ? 0.01 : 0.001
                        };
                        
                        enemies.push(enemy);
                    }
                }
            }
            
            // Restart game
            function restartGame() {
                resetGame();
                setGameState('playing');
                
                // Restart game loop if needed
                if (!lastTime) {
                    lastTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
            }
            
            // Start next level
            function startNextLevel() {
                level++;
                resetLevel();
                setGameState('playing');
            }
            
            // Handle keyboard controls
            function handleKeyDown(e) {
                if (e.key === 'ArrowLeft' || e.key === 'a') {
                    keys.left = true;
                } else if (e.key === 'ArrowRight' || e.key === 'd') {
                    keys.right = true;
                } else if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') {
                    keys.fire = true;
                }
            }
            
            function handleKeyUp(e) {
                if (e.key === 'ArrowLeft' || e.key === 'a') {
                    keys.left = false;
                } else if (e.key === 'ArrowRight' || e.key === 'd') {
                    keys.right = false;
                } else if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') {
                    keys.fire = false;
                }
            }
            
            // Get high score from local storage
            function getHighScore() {
                return parseInt(localStorage.getItem('highScore') || '0');
            }
            
            // Save high score to local storage
            function saveHighScore() {
                const highScore = getHighScore();
                if (score > highScore) {
                    localStorage.setItem('highScore', score.toString());
                }
            }
            
            // Load high score
            function loadHighScore() {
                const highScore = getHighScore();
                document.getElementById('high-score').textContent = `HIGH: ${highScore}`;
            }
            
            // Create player projectile
            function createPlayerProjectile() {
                const now = performance.now();
                const fireDelay = player.isRapidFire ? 120 : 300;
                
                if (now - player.lastFired < fireDelay) {
                    return;
                }
                
                player.lastFired = now;
                
                // Select a random projectile type
                const projectileTypes = ['projectileGavel', 'projectilePaper', 'projectileDollar'];
                const randomType = projectileTypes[Math.floor(Math.random() * projectileTypes.length)];
                
                const projectile = {
                    x: player.x + (player.width / 2) - (PROJECTILE_WIDTH / 2),
                    y: player.y - PROJECTILE_HEIGHT,
                    width: PROJECTILE_WIDTH,
                    height: PROJECTILE_HEIGHT,
                    speed: player.projectileSpeed,
                    type: randomType // Store the selected type
                };
                
                playerProjectiles.push(projectile);
                playShoot();
            }
            
            // Create enemy projectile
            function createEnemyProjectile(enemy) {
                // Don't fire if off screen
                if (enemy.y + enemy.height > canvas.height) {
                    return;
                }
                
                // Determine projectile type based on enemy type and level
                let projectilePattern = 'single';
                
                // Boss enemies have special patterns every 6th level
                if (enemy.isBoss && level % 6 === 0) {
                    projectilePattern = 'circular';
                } else if (enemy.isBoss) {
                    projectilePattern = 'spread';
                }
                
                if (projectilePattern === 'single') {
                    // Single projectile
                    const projectile = {
                        x: enemy.x + (enemy.width / 2) - (PROJECTILE_WIDTH / 2),
                        y: enemy.y + enemy.height,
                        width: PROJECTILE_WIDTH,
                        height: PROJECTILE_HEIGHT,
                        speed: 0.4 // SLOWED DOWN
                    };
                    
                    enemyProjectiles.push(projectile);
                } else if (projectilePattern === 'spread') {
                    // Spread pattern (3 projectiles)
                    for (let i = -1; i <= 1; i++) {
                        const projectile = {
                            x: enemy.x + (enemy.width / 2) - (PROJECTILE_WIDTH / 2),
                            y: enemy.y + enemy.height,
                            width: PROJECTILE_WIDTH,
                            height: PROJECTILE_HEIGHT,
                            speed: 0.4, // SLOWED DOWN
                            xVelocity: i * 0.15 // SLOWED DOWN
                        };
                        
                        enemyProjectiles.push(projectile);
                    }
                } else if (projectilePattern === 'circular') {
                    // Circular pattern (6 projectiles)
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const projectile = {
                            x: enemy.x + (enemy.width / 2) - (PROJECTILE_WIDTH / 2),
                            y: enemy.y + enemy.height,
                            width: PROJECTILE_WIDTH,
                            height: PROJECTILE_HEIGHT,
                            speed: 0.4, // SLOWED DOWN
                            xVelocity: Math.sin(angle) * 0.25, // SLOWED DOWN
                            yVelocity: Math.cos(angle) * 0.25 // SLOWED DOWN
                        };
                        
                        enemyProjectiles.push(projectile);
                    }
                }
                
                playEnemyProjectile();
            }
            
            // Create power-up
            function createPowerUp() {
                const now = performance.now();
                
                // Only create power-ups every 15-30 seconds
                if (now - lastPowerUpTime < 15000 + Math.random() * 15000) {
                    return;
                }
                
                lastPowerUpTime = now;
                
                const powerUp = {
                    x: Math.random() * (canvas.width - 40),
                    y: 70 + Math.random() * 100,
                    width: 40,
                    height: 40,
                    type: 'rapidFire',
                    speed: 0.1 // SLOWED DOWN
                };
                
                powerUps.push(powerUp);
            }
            
            // Create speech bubble
            function createSpeechBubble(enemy, text) {
                // Limit to 2 active speech bubbles to prevent clutter
                if (speechBubbles.length >= 2) {
                    return;
                }
                
                // Don't create speech bubble if enemy is off screen
                if (enemy.y + enemy.height > canvas.height) {
                    return;
                }
                
                // Choose appropriate quote
                let quote;
                if (enemy.isBoss) {
                    quote = enemy.type === 'fed' ? 
                        fedBossQuotes[Math.floor(Math.random() * fedBossQuotes.length)] : 
                        dogeBossQuotes[Math.floor(Math.random() * dogeBossQuotes.length)];
                } else {
                    quote = enemy.type === 'fed' ? 
                        fedEnemyQuotes[Math.floor(Math.random() * fedEnemyQuotes.length)] : 
                        dogeEnemyQuotes[Math.floor(Math.random() * dogeEnemyQuotes.length)];
                }
                
                text = quote || text;
                
                // Calculate bubble dimensions based on text length
                const maxWidth = 180;
                const fontSize = 12; // Slightly smaller
                const padding = 12;
                const lineHeight = fontSize * 1.5;
                
                // Measure text and wrap if needed
                const words = text.split(' ');
                let lines = [];
                let currentLine = words[0];
                
                for (let i = 1; i < words.length; i++) {
                    const testLine = currentLine + ' ' + words[i];
                    const testWidth = ctx.measureText(testLine).width;
                    
                    if (testWidth > maxWidth - (padding * 2)) {
                        lines.push(currentLine);
                        currentLine = words[i];
                    } else {
                        currentLine = testLine;
                    }
                }
                lines.push(currentLine);
                
                const bubbleWidth = maxWidth;
                const bubbleHeight = lines.length * lineHeight + padding * 2;
                
                // Create speech bubble
                const speechBubble = {
                    x: enemy.x + enemy.width / 2,
                    y: enemy.y,
                    width: bubbleWidth,
                    height: bubbleHeight,
                    text: text,
                    lines: lines,
                    enemy: enemy,
                    duration: enemy.isBoss ? 5000 : 4000,
                    createdAt: performance.now(),
                    position: enemy.y < 150 ? 'side' : 'top' // Position on side if near top
                };
                
                speechBubbles.push(speechBubble);
            }
            
            // Create defeated enemy animation
            function createDefeatedEnemy(enemy) {
                // Apply random velocity vector and rotation with UPWARD movement
                const defeatedEnemy = {
                    ...enemy,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 20,
                    xVelocity: (Math.random() - 0.5) * 2,
                    yVelocity: -2 - Math.random() * 2, // UPWARD velocity
                    gravity: -0.05, // NEGATIVE gravity to float upward
                    opacity: 1,
                    createdAt: performance.now(),
                    trail: []
                };
                
                defeatedEnemies.push(defeatedEnemy);
            }
            
            // Apply screen shake effect
            function applyScreenShake(intensity, duration) {
                screenShake.intensity = intensity;
                screenShake.duration = duration;
                screenShake.timeLeft = duration;
            }
            
            // Check for collision between two objects
            function checkCollision(obj1, obj2) {
                return (
                    obj1.x < obj2.x + obj2.width &&
                    obj1.x + obj1.width > obj2.x &&
                    obj1.y < obj2.y + obj2.height &&
                    obj1.y + obj1.height > obj2.y
                );
            }
            
            // Update player position
            function updatePlayer(deltaTime) {
                // Handle movement
                if (keys.left) {
                    player.x -= canvas.width * player.speed * deltaTime / 1000;
                }
                
                if (keys.right) {
                    player.x += canvas.width * player.speed * deltaTime / 1000;
                }
                
                // Keep player within canvas bounds
                if (player.x < 0) {
                    player.x = 0;
                } else if (player.x + player.width > canvas.width) {
                    player.x = canvas.width - player.width;
                }
                
                // Handle firing
                if (keys.fire) {
                    createPlayerProjectile();
                }
                
                // Update rapid fire timer
                if (player.isRapidFire) {
                    const remainingTime = (player.powerUpDuration - (performance.now() - player.rapidFireTime)) / 1000;
                    
                    // Update HUD with power-up status
                    document.getElementById('power-up').textContent = `RAPID: ${remainingTime.toFixed(1)}s`;
                    
                    if (performance.now() - player.rapidFireTime > player.powerUpDuration) {
                        player.isRapidFire = false;
                        document.getElementById('power-up').textContent = '';
                    }
                }
            }
            
            // Update enemy formation
            function updateEnemies(deltaTime) {
                if (enemies.length === 0) {
                    // Level complete if all enemies are defeated
                    setGameState('levelComplete');
                    return;
                }
                
                // Find formation bounds
                let leftmost = canvas.width;
                let rightmost = 0;
                let lowest = 0;
                
                enemies.forEach(enemy => {
                    leftmost = Math.min(leftmost, enemy.x);
                    rightmost = Math.max(rightmost, enemy.x + enemy.width);
                    lowest = Math.max(lowest, enemy.y + enemy.height);
                });
                
                // Move formation
                let dropFormation = false;
                
                if (formationDirection === 1 && rightmost + canvas.width * formationSpeed * deltaTime / 1000 > canvas.width) {
                    formationDirection = -1;
                    dropFormation = true;
                } else if (formationDirection === -1 && leftmost - canvas.width * formationSpeed * deltaTime / 1000 < 0) {
                    formationDirection = 1;
                    dropFormation = true;
                }
                
                // Move enemy formation
                enemies.forEach(enemy => {
                    // Move horizontally
                    enemy.x += canvas.width * formationSpeed * formationDirection * deltaTime / 1000;
                    
                    // Drop formation if needed
                    if (dropFormation) {
                        enemy.y += formationDropDistance;
                    }
                    
                    // Game over if enemies reach the bottom
                    if (enemy.y + enemy.height > player.y) {
                        saveHighScore();
                        setGameState('gameOver');
                    }
                    
                    // Random enemy firing
                    if (Math.random() < enemyFireRate * deltaTime / 16.67) {
                        // Lower enemies are more likely to fire
                        const lowestInColumn = enemies.reduce((lowest, current) => {
                            const sameColumn = Math.abs(current.x + current.width/2 - (enemy.x + enemy.width/2)) < enemy.width/2;
                            return sameColumn && current.y > lowest.y ? current : lowest;
                        }, { y: -Infinity });
                        
                        if (lowestInColumn === enemy) {
                            createEnemyProjectile(enemy);
                        }
                    }
                    
                    // Random enemy speech
                    const now = performance.now();
                    if (now - enemy.lastSpeechTime > 5000 && Math.random() < enemy.speechChance * deltaTime / 16.67) {
                        enemy.lastSpeechTime = now;
                        createSpeechBubble(enemy);
                    }
                });
            }
            
            // Update player projectiles
            function updatePlayerProjectiles(deltaTime) {
                for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                    const projectile = playerProjectiles[i];
                    
                    // Move projectile
                    projectile.y -= canvas.height * projectile.speed * deltaTime / 1000;
                    
                    // Remove if off screen
                    if (projectile.y + projectile.height < 0) {
                        playerProjectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Check for collision with enemies
                    let hitEnemy = false;
                    
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        
                        if (checkCollision(projectile, enemy)) {
                            enemy.health--;
                            hitEnemy = true;
                            
                            // Award points
                            score += enemy.isBoss ? 50 : 10;
                            
                            // Update HUD
                            updateHUD();
                            
                            // If enemy is defeated
                            if (enemy.health <= 0) {
                                createDefeatedEnemy(enemy);
                                enemies.splice(j, 1);
                                playEnemyHit();
                                
                                // Apply screen shake
                                const shakeIntensity = enemy.isBoss ? 10 : 5;
                                const shakeDuration = enemy.isBoss ? 500 : 250;
                                applyScreenShake(shakeIntensity, shakeDuration);
                            }
                            
                            break;
                        }
                    }
                    
                    // Remove projectile if it hit an enemy
                    if (hitEnemy) {
                        playerProjectiles.splice(i, 1);
                    }
                }
            }
            
            // Update enemy projectiles
            function updateEnemyProjectiles(deltaTime) {
                for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                    const projectile = enemyProjectiles[i];
                    
                    // Move projectile
                    projectile.y += canvas.height * projectile.speed * deltaTime / 1000;
                    
                    // Move horizontally if it has x velocity
                    if (projectile.xVelocity) {
                        projectile.x += canvas.width * projectile.xVelocity * deltaTime / 1000;
                    }
                    
                    // Custom y velocity if specified (for circular pattern)
                    if (projectile.yVelocity) {
                        projectile.y += canvas.height * projectile.yVelocity * deltaTime / 1000;
                    }
                    
                    // Remove if off screen
                    if (projectile.y > canvas.height || 
                        projectile.x + projectile.width < 0 || 
                        projectile.x > canvas.width) {
                        enemyProjectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Check for collision with player
                    if (checkCollision(projectile, player)) {
                        enemyProjectiles.splice(i, 1);
                        lives--;
                        
                        // Update HUD
                        updateHUD();
                        
                        if (lives <= 0) {
                            saveHighScore();
                            setGameState('gameOver');
                        } else {
                            // Apply screen shake
                            applyScreenShake(15, 500);
                        }
                    }
                }
            }
            
            // Update power-ups
            function updatePowerUps(deltaTime) {
                // Chance to create a power-up
                if (Math.random() < powerUpChance * deltaTime / 16.67) {
                    createPowerUp();
                }
                
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const powerUp = powerUps[i];
                    
                    // Move power-up down
                    powerUp.y += canvas.height * powerUp.speed * deltaTime / 1000;
                    
                    // Remove if off screen
                    if (powerUp.y > canvas.height) {
                        powerUps.splice(i, 1);
                        continue;
                    }
                    
                    // Check for collision with player
                    if (checkCollision(powerUp, player)) {
                        powerUps.splice(i, 1);
                        
                        // Apply power-up effect
                        if (powerUp.type === 'rapidFire') {
                            player.isRapidFire = true;
                            player.rapidFireTime = performance.now();
                            playPowerup();
                        }
                    }
                }
            }
            
            // Update speech bubbles
            function updateSpeechBubbles(deltaTime) {
                const now = performance.now();
                
                for (let i = speechBubbles.length - 1; i >= 0; i--) {
                    const bubble = speechBubbles[i];
                    
                    // Remove if duration expired
                    if (now - bubble.createdAt > bubble.duration) {
                        speechBubbles.splice(i, 1);
                    }
                }
            }
            
            // Update defeated enemies - FLOAT UP INSTEAD OF DOWN
            function updateDefeatedEnemies(deltaTime) {
                const now = performance.now();
                
                for (let i = defeatedEnemies.length - 1; i >= 0; i--) {
                    const enemy = defeatedEnemies[i];
                    
                    // Apply physics
                    enemy.x += enemy.xVelocity * deltaTime / 16.67;
                    enemy.y += enemy.yVelocity * deltaTime / 16.67;
                    
                    // Apply negative gravity to float upward
                    enemy.yVelocity += enemy.gravity * deltaTime / 16.67;
                    
                    enemy.rotation += enemy.rotationSpeed * deltaTime / 16.67;
                    
                    // Add trail point
                    if (now % 50 < 16.67) { // Add a point roughly every 50ms
                        enemy.trail.push({ x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2, opacity: 1 });
                    }
                    
                    // Update trail opacity
                    for (let j = enemy.trail.length - 1; j >= 0; j--) {
                        const point = enemy.trail[j];
                        point.opacity -= 0.05 * deltaTime / 16.67;
                        
                        // Remove faded trail points
                        if (point.opacity <= 0) {
                            enemy.trail.splice(j, 1);
                        }
                    }
                    
                    // Fade out gradually
                    if (now - enemy.createdAt > 800) {
                        enemy.opacity -= 0.03 * deltaTime / 16.67;
                    }
                    
                    // Remove if invisible or off screen (TOP of screen)
                    if (enemy.opacity <= 0 || enemy.y + enemy.height < -50) {
                        defeatedEnemies.splice(i, 1);
                    }
                }
            }
            
            // Update screen shake effect
            function updateScreenShake(deltaTime) {
                if (screenShake.timeLeft > 0) {
                    screenShake.timeLeft -= deltaTime;
                    
                    // Decrease intensity over time
                    const progress = screenShake.timeLeft / screenShake.duration;
                    screenShake.intensity = screenShake.intensity * progress;
                }
            }
            
            // Update HUD display
            function updateHUD() {
                document.getElementById('score').textContent = `SCORE: ${score}`;
                document.getElementById('level').textContent = `LEVEL: ${level}`;
                document.getElementById('lives').textContent = `LIVES: ${lives}`;
                
                // Update high score if needed
                if (score > getHighScore()) {
                    document.getElementById('high-score').textContent = `HIGH: ${score}`;
                }
            }
            
            // Main game update function
            function update(deltaTime) {
                if (gameState !== 'playing') {
                    return;
                }
                
                updatePlayer(deltaTime);
                updateEnemies(deltaTime);
                updatePlayerProjectiles(deltaTime);
                updateEnemyProjectiles(deltaTime);
                updatePowerUps(deltaTime);
                updateSpeechBubbles(deltaTime);
                updateDefeatedEnemies(deltaTime);
                updateScreenShake(deltaTime);
            }
            
            // Render game objects
            function render() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Apply screen shake
                let shakeX = 0;
                let shakeY = 0;
                
                if (screenShake.timeLeft > 0) {
                    shakeX = (Math.random() - 0.5) * 2 * screenShake.intensity;
                    shakeY = (Math.random() - 0.5) * 2 * screenShake.intensity;
                    
                    ctx.save();
                    ctx.translate(shakeX, shakeY);
                }
                
                // Draw player
                if (gameState === 'playing') {
                    const playerImage = svgCache[characterType + 'Player'];
                    if (playerImage) {
                        ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
                    }
                }
                
                // Draw enemies
                enemies.forEach(enemy => {
                    // Draw enemy with pulsing effect for bosses
                    const enemyImage = svgCache[enemy.type + (enemy.isBoss ? 'Boss' : 'Enemy')];
                    if (enemyImage) {
                        if (enemy.isBoss) {
                            // Add pulsing glow for bosses
                            const pulseAmount = Math.sin(performance.now() / 300) * 0.2 + 0.8;
                            
                            ctx.save();
                            ctx.globalAlpha = 0.3;
                            ctx.drawImage(
                                enemyImage, 
                                enemy.x - 5, 
                                enemy.y - 5, 
                                enemy.width + 10, 
                                enemy.height + 10
                            );
                            ctx.restore();
                        }
                        
                        ctx.drawImage(enemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                });
                
                // Draw player projectiles with random types
                playerProjectiles.forEach(projectile => {
                    const projectileType = projectile.type || 'projectileGavel'; // Default fallback
                    const projectileImage = svgCache[projectileType];
                    
                    if (projectileImage) {
                        ctx.drawImage(
                            projectileImage, 
                            projectile.x, 
                            projectile.y, 
                            projectile.width, 
                            projectile.height
                        );
                    }
                });
                
                // Draw enemy projectiles
                const enemyProjectileImage = svgCache.enemyProjectile;
                enemyProjectiles.forEach(projectile => {
                    if (enemyProjectileImage) {
                        ctx.drawImage(
                            enemyProjectileImage, 
                            projectile.x, 
                            projectile.y, 
                            projectile.width, 
                            projectile.height
                        );
                    }
                });
                
                // Draw power-ups
                const powerUpImage = svgCache.powerUp;
                powerUps.forEach(powerUp => {
                    if (powerUpImage) {
                        ctx.drawImage(
                            powerUpImage, 
                            powerUp.x, 
                            powerUp.y, 
                            powerUp.width, 
                            powerUp.height
                        );
                    }
                });
                
                // Draw defeated enemies
                defeatedEnemies.forEach(enemy => {
                    const enemyImage = svgCache[enemy.type + (enemy.isBoss ? 'Boss' : 'Enemy')];
                    if (enemyImage) {
                        // Draw trail
                        enemy.trail.forEach(point => {
                            ctx.save();
                            ctx.globalAlpha = point.opacity * 0.5;
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                            ctx.fillStyle = enemy.type === 'fed' ? '#000080' : '#444444';
                            ctx.fill();
                            ctx.restore();
                        });
                        
                        // Draw spinning enemy
                        ctx.save();
                        ctx.globalAlpha = enemy.opacity;
                        ctx.translate(
                            enemy.x + enemy.width / 2, 
                            enemy.y + enemy.height / 2
                        );
                        ctx.rotate(enemy.rotation * Math.PI / 180);
                        
                        // Apply squash and stretch effect
                        const stretch = (1 + Math.sin(performance.now() / 100) * 0.1);
                        ctx.scale(1 / stretch, stretch);
                        
                        ctx.drawImage(
                            enemyImage, 
                            -enemy.width / 2, 
                            -enemy.height / 2, 
                            enemy.width, 
                            enemy.height
                        );
                        ctx.restore();
                    }
                });
                
                // Draw speech bubbles
                speechBubbles.forEach(bubble => {
                    drawSpeechBubble(bubble);
                });
                
                // Restore canvas if screen shake was applied
                if (screenShake.timeLeft > 0) {
                    ctx.restore();
                }
            }
            
            // Draw speech bubble with improved positioning
            function drawSpeechBubble(bubble) {
                if (!bubble.enemy) return;
                
                const fontSize = 12;
                const lineHeight = fontSize * 1.5;
                const padding = 12;
                
                // Calculate bubble dimensions
                const bubbleWidth = bubble.width;
                const bubbleHeight = bubble.height;
                
                // Position bubble based on enemy position - either above or to the side
                let bubbleX, bubbleY, pointerX, pointerY;
                let pointerBaseLeft, pointerBaseRight;
                
                if (bubble.position === 'side') {
                    // Position to the side if enemy is near top
                    bubbleX = bubble.enemy.x + bubble.enemy.width + 10;
                    bubbleY = bubble.enemy.y;
                    
                    // If bubble would go off right edge, put it on left instead
                    if (bubbleX + bubbleWidth > canvas.width - 10) {
                        bubbleX = bubble.enemy.x - bubbleWidth - 10;
                    }
                    
                    // Ensure bubble is at least partially on screen
                    bubbleX = Math.max(10, Math.min(bubbleX, canvas.width - bubbleWidth - 10));
                    bubbleY = Math.max(10, Math.min(bubbleY, canvas.height - bubbleHeight - 10));
                    
                    // Position pointer
                    if (bubble.enemy.x > bubbleX + bubbleWidth) {
                        // Pointer on right side of bubble
                        pointerX = bubble.enemy.x;
                        pointerY = bubble.enemy.y + bubble.enemy.height / 3;
                        pointerBaseLeft = bubbleX + bubbleWidth;
                        pointerBaseRight = bubbleX + bubbleWidth;
                    } else {
                        // Pointer on left side of bubble
                        pointerX = bubble.enemy.x + bubble.enemy.width;
                        pointerY = bubble.enemy.y + bubble.enemy.height / 3;
                        pointerBaseLeft = bubbleX;
                        pointerBaseRight = bubbleX;
                    }
                } else {
                    // Position above enemy (default)
                    bubbleX = bubble.enemy.x + bubble.enemy.width / 2 - bubbleWidth / 2;
                    bubbleY = bubble.enemy.y - bubbleHeight - 15;
                    
                    // Ensure bubble is on screen
                    bubbleX = Math.max(10, Math.min(bubbleX, canvas.width - bubbleWidth - 10));
                    bubbleY = Math.max(10, bubbleY);
                    
                    // Position pointer
                    pointerX = bubble.enemy.x + bubble.enemy.width / 2;
                    pointerY = bubble.enemy.y;
                    pointerBaseLeft = Math.max(bubbleX + 10, Math.min(pointerX - 10, bubbleX + bubbleWidth - 20));
                    pointerBaseRight = Math.max(bubbleX + 20, Math.min(pointerX + 10, bubbleX + bubbleWidth - 10));
                }
                
                // Draw the main bubble rectangle
                ctx.fillStyle = 'white';
                ctx.beginPath();
                
                // Rounded rectangle for the bubble
                ctx.moveTo(bubbleX + 10, bubbleY);
                ctx.lineTo(bubbleX + bubbleWidth - 10, bubbleY);
                ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + 10);
                ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
                ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
                
                if (bubble.position === 'side') {
                    // Side positioning - pointer on left or right side
                    if (pointerBaseLeft === bubbleX) {
                        // Pointer on left side
                        ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
                        ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
                        ctx.lineTo(bubbleX, bubbleY + (bubbleHeight * 0.75));
                        ctx.lineTo(pointerX, pointerY);
                        ctx.lineTo(bubbleX, bubbleY + (bubbleHeight * 0.25));
                        ctx.lineTo(bubbleX, bubbleY + 10);
                    } else {
                        // Pointer on right side
                        ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
                        ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
                        ctx.lineTo(bubbleX, bubbleY + 10);
                        ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 10, bubbleY);
                        ctx.closePath();
                        
                        // Draw the pointer separately
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(bubbleX + bubbleWidth, bubbleY + (bubbleHeight * 0.25));
                        ctx.lineTo(pointerX, pointerY);
                        ctx.lineTo(bubbleX + bubbleWidth, bubbleY + (bubbleHeight * 0.75));
                    }
                } else {
                    // Top positioning (default) - pointer on bottom
                    ctx.lineTo(pointerBaseRight, bubbleY + bubbleHeight);
                    ctx.lineTo(pointerX, pointerY);
                    ctx.lineTo(pointerBaseLeft, bubbleY + bubbleHeight);
                    ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
                }
                
                // Complete the path if not already closed
                if (!(bubble.position === 'side' && pointerBaseLeft === bubbleX)) {
                    ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
                    ctx.lineTo(bubbleX, bubbleY + 10);
                }
                
                ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 10, bubbleY);
                ctx.closePath();
                ctx.fill();
                
                // Draw border (stroke) - but not on the pointer
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1.5;
                
                if (bubble.position === 'side') {
                    if (pointerBaseLeft === bubbleX) {
                        // Left side pointer
                        // Top edge
                        ctx.beginPath();
                        ctx.moveTo(bubbleX, bubbleY + 10);
                        ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 10, bubbleY);
                        ctx.lineTo(bubbleX + bubbleWidth - 10, bubbleY);
                        ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + 10);
                        ctx.stroke();
                        
                        // Right edge
                        ctx.beginPath();
                        ctx.moveTo(bubbleX + bubbleWidth, bubbleY + 10);
                        ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
                        ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
                        ctx.stroke();
                        
                        // Bottom edge
                        ctx.beginPath();
                        ctx.moveTo(bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
                        ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
                        ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
                        ctx.stroke();
                        
                        // Left edges (around pointer)
                        ctx.beginPath();
                        ctx.moveTo(bubbleX, bubbleY + bubbleHeight - 10);
                        ctx.lineTo(bubbleX, bubbleY + (bubbleHeight * 0.75));
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(bubbleX, bubbleY + (bubbleHeight * 0.25));
                        ctx.lineTo(bubbleX, bubbleY + 10);
                        ctx.stroke();
                        
                        // Pointer edges
                        ctx.beginPath();
                        ctx.moveTo(bubbleX, bubbleY + (bubbleHeight * 0.75));
                        ctx.lineTo(pointerX, pointerY);
                        ctx.lineTo(bubbleX, bubbleY + (bubbleHeight * 0.25));
                        ctx.stroke();
                    } else {
                        // Right side pointer
                        // Left & top edges
                        ctx.beginPath();
                        ctx.moveTo(bubbleX, bubbleY + 10);
                        ctx.lineTo(bubbleX, bubbleY + bubbleHeight - 10);
                        ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX + 10, bubbleY + bubbleHeight);
                        ctx.lineTo(bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
                        ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
                        ctx.stroke();
                        
                        // Right edges (around pointer)
                        ctx.beginPath();
                        ctx.moveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
                        ctx.lineTo(bubbleX + bubbleWidth, bubbleY + (bubbleHeight * 0.75));
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(bubbleX + bubbleWidth, bubbleY + (bubbleHeight * 0.25));
                        ctx.lineTo(bubbleX + bubbleWidth, bubbleY + 10);
                        ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth - 10, bubbleY);
                        ctx.lineTo(bubbleX + 10, bubbleY);
                        ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX, bubbleY + 10);
                        ctx.stroke();
                        
                        // Pointer edges
                        ctx.beginPath();
                        ctx.moveTo(bubbleX + bubbleWidth, bubbleY + (bubbleHeight * 0.75));
                        ctx.lineTo(pointerX, pointerY);
                        ctx.lineTo(bubbleX + bubbleWidth, bubbleY + (bubbleHeight * 0.25));
                        ctx.stroke();
                    }
                } else {
                    // Top positioning - standard bubble
                    // Top edge
                    ctx.beginPath();
                    ctx.moveTo(bubbleX + 10, bubbleY);
                    ctx.lineTo(bubbleX + bubbleWidth - 10, bubbleY);
                    ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + 10);
                    ctx.stroke();
                    
                    // Right edge
                    ctx.beginPath();
                    ctx.moveTo(bubbleX + bubbleWidth, bubbleY + 10);
                    ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
                    ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
                    ctx.stroke();
                    
                    // Bottom edges (around pointer)
                    ctx.beginPath();
                    ctx.moveTo(bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
                    ctx.lineTo(pointerBaseRight, bubbleY + bubbleHeight);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(pointerBaseLeft, bubbleY + bubbleHeight);
                    ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
                    ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
                    ctx.stroke();
                    
                    // Left edge
                    ctx.beginPath();
                    ctx.moveTo(bubbleX, bubbleY + bubbleHeight - 10);
                    ctx.lineTo(bubbleX, bubbleY + 10);
                    ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 10, bubbleY);
                    ctx.stroke();
                    
                    // Pointer edges
                    ctx.beginPath();
                    ctx.moveTo(pointerBaseRight, bubbleY + bubbleHeight);
                    ctx.lineTo(pointerX, pointerY);
                    ctx.lineTo(pointerBaseLeft, bubbleY + bubbleHeight);
                    ctx.stroke();
                }
                
                // Draw text
                ctx.fillStyle = 'black';
                ctx.font = `${fontSize}px "Press Start 2P"`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                
                // Draw each line of text
                if (bubble.lines) {
                    for (let i = 0; i < bubble.lines.length; i++) {
                        ctx.fillText(
                            bubble.lines[i], 
                            bubbleX + padding, 
                            bubbleY + padding + (i * lineHeight)
                        );
                    }
                } else {
                    // Fallback if lines not provided
                    ctx.fillText(bubble.text, bubbleX + padding, bubbleY + padding);
                }
            }
            
            // Main game loop
            function gameLoop(timestamp) {
                // Calculate delta time
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;
                
                // Update game state
                update(deltaTime);
                
                // Render game
                render();
                
                // Continue game loop
                requestAnimationFrame(gameLoop);
            }
            
            // Start the game when the page loads
            window.addEventListener('load', init);
        })();
    </script>
</body>
</html>
